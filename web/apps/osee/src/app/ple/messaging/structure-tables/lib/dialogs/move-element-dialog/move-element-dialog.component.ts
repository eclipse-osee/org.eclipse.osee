/*********************************************************************
 * Copyright (c) 2024 Boeing
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Boeing - initial API and implementation
 **********************************************************************/
import { Component, computed, inject, signal } from '@angular/core';
import { FormsModule } from '@angular/forms';
import {
	MatAutocomplete,
	MatAutocompleteTrigger,
	MatOption,
} from '@angular/material/autocomplete';
import { MatButton } from '@angular/material/button';
import {
	MAT_DIALOG_DATA,
	MatDialogActions,
	MatDialogClose,
	MatDialogContent,
	MatDialogTitle,
} from '@angular/material/dialog';
import { MatIcon } from '@angular/material/icon';
import {
	MatFormField,
	MatInput,
	MatLabel,
	MatSuffix,
} from '@angular/material/input';
import { MatSelect } from '@angular/material/select';
import {
	element,
	elementSentinel,
	structure,
} from '@osee/messaging/shared/types';
import { moveLocation, moveLocations } from '../../types/structure-tables';

@Component({
	selector: 'osee-move-element-dialog',
	standalone: true,
	imports: [
		MatDialogContent,
		MatDialogActions,
		MatDialogClose,
		MatDialogTitle,
		MatButton,
		MatInput,
		MatAutocomplete,
		MatAutocompleteTrigger,
		MatFormField,
		MatLabel,
		MatIcon,
		FormsModule,
		MatOption,
		MatSuffix,
		MatSelect,
	],
	template: `
		<h1 mat-dialog-title>Move {{ data().element.name.value }}</h1>
		<mat-dialog-content>
			<div class="tw-flex tw-flex-col tw-gap-4">
				<mat-form-field subscriptSizing="dynamic">
					<mat-label>Move To</mat-label>
					<mat-select [(ngModel)]="selectedLocation">
						@for (option of locations; track option) {
							<mat-option [value]="option">
								{{ option }}
							</mat-option>
						}
					</mat-select>
				</mat-form-field>

				@if (
					selectedLocation() === 'Before Element' ||
					selectedLocation() === 'After Element'
				) {
					<mat-form-field subscriptSizing="dynamic">
						<mat-label>Select an Element</mat-label>
						<input
							type="text"
							matInput
							#input
							[(ngModel)]="filter"
							name="elementsInput"
							#elementsInput="ngModel"
							[matAutocomplete]="autoElements" />
						@if (filter() !== '') {
							<mat-icon
								class="tw-cursor-pointer"
								matIconSuffix
								(mousedown)="clearFilter()"
								>close</mat-icon
							>
						}
						<mat-autocomplete
							autoActiveFirstOption="true"
							autoSelectActiveOption="true"
							#autoElements="matAutocomplete"
							[displayWith]="displayFn"
							(optionSelected)="updateValue($event.option.value)">
							@for (element of elements(); track element.id) {
								<mat-option
									[id]="element.id"
									[value]="element">
									{{ element.name.value }}
								</mat-option>
							}
						</mat-autocomplete>
					</mat-form-field>
				}
			</div>
		</mat-dialog-content>
		<mat-dialog-actions>
			<button
				mat-button
				mat-dialog-close=""
				data-cy="cancel-btn"
				cdkFocusInitial>
				Cancel
			</button>
			<button
				mat-flat-button
				class="primary-button"
				[mat-dialog-close]="afterArtifact()"
				data-cy="submit-btn">
				Ok
			</button>
		</mat-dialog-actions>
	`,
})
export class MoveElementDialogComponent {
	data = signal(
		inject<{ element: element; structure: structure }>(MAT_DIALOG_DATA)
	);

	filter = signal('');

	elements = computed(() =>
		this.data().structure.elements.filter(
			(e) =>
				!e.autogenerated &&
				e.id !== this.data().element.id &&
				e.name.value.toLowerCase().includes(this.filter().toLowerCase())
		)
	);

	selectedLocation = signal<moveLocation>('End');
	selectedElement = signal<element>(elementSentinel);

	afterArtifact = computed(() => {
		if (this.selectedLocation() === 'Start') {
			return 'start';
		}
		if (this.selectedLocation() === 'After Element') {
			return this.selectedElement().id;
		}
		if (this.selectedLocation() === 'Before Element') {
			const selectedElementIndex =
				this.data().structure.elements.findIndex(
					(e) => e.id === this.selectedElement().id
				);
			if (selectedElementIndex === -1) {
				return 'end';
			}
			if (selectedElementIndex === 0) {
				return 'start';
			}
			return this.data().structure.elements[selectedElementIndex - 1].id;
		}
		return 'end';
	});

	locations = moveLocations;

	updateValue(element: element) {
		this.filter.set(element.name.value);
		this.selectedElement.set(element);
	}

	displayFn(element: element | string) {
		if (!element) {
			return '';
		}
		if (typeof element === 'string') {
			return element;
		}
		return element.name.value;
	}

	clearFilter() {
		this.filter.set('');
	}
}
