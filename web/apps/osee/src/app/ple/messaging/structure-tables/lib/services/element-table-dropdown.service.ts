/*********************************************************************
 * Copyright (c) 2023 Boeing
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Boeing - initial API and implementation
 **********************************************************************/
import { Injectable, inject } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { applic } from '@osee/applicability/types';
import {
	PlatformTypeActionsService,
	WarningDialogService,
} from '@osee/messaging/shared/services';
import { STRUCTURE_SERVICE_TOKEN } from '@osee/messaging/shared/tokens';
import {
	EditViewFreeTextDialog,
	ElementDialog,
	element,
	structure,
} from '@osee/messaging/shared/types';
import { difference } from '@osee/shared/types/change-report';
import { filter, iif, map, of, switchMap, take } from 'rxjs';
import { AddElementDialogComponent } from '../dialogs/add-element-dialog/add-element-dialog.component';
import { DefaultAddElementDialog } from '../dialogs/add-element-dialog/add-element-dialog.default';
import { EditElementDialogComponent } from '../dialogs/edit-element-dialog/edit-element-dialog.component';
import { RemoveElementDialogData } from '../dialogs/remove-element-dialog/remove-element-dialog';
import { RemoveElementDialogComponent } from '../dialogs/remove-element-dialog/remove-element-dialog.component';
import { EditViewFreeTextFieldDialogComponent } from '@osee/shared/components';

@Injectable({
	providedIn: 'any',
})
export class ElementTableDropdownService {
	private dialog = inject(MatDialog);
	private structureService = inject(STRUCTURE_SERVICE_TOKEN);
	private warningDialogService = inject(WarningDialogService);

	private platformTypeActionsService = inject(PlatformTypeActionsService);

	private _isStructure(value: structure | element): value is structure {
		return (value as structure).elements !== undefined;
	}

	openAddElementDialog(
		parent: structure | element,
		isArray: boolean,
		allowArray: boolean,
		afterElement?: string,
		copyElement?: element
	) {
		const dialogData = new DefaultAddElementDialog(
			parent.id || '',
			parent.name.value || '',
			structuredClone(copyElement),
			structuredClone(copyElement), //make a copy
			'add',
			allowArray
		);
		const dialogRef = this.dialog.open(AddElementDialogComponent, {
			data: dialogData,
			minWidth: '70vw',
		});
		const createElement = dialogRef.afterClosed().pipe(
			take(1),
			filter(
				(data) =>
					data !== undefined &&
					data !== null &&
					data?.element !== undefined
			),
			switchMap((dialogResults: ElementDialog) =>
				!this._isStructure(parent)
					? this.warningDialogService
							.openElementDialog(dialogResults.element)
							.pipe(map((_) => dialogResults))
					: this.warningDialogService
							.openStructureDialog(parent)
							.pipe(map((_) => dialogResults))
			),
			map((data) => {
				const {
					id,
					gammaId,
					autogenerated,
					elementSizeInBits,
					elementSizeInBytes,
					beginByte,
					beginWord,
					endByte,
					endWord,
					arrayElements,
					platformType,
					applicability,
					added,
					deleted,
					changes,
					...element
				} = data.element;
				const attributeKeys = Object.keys(
					element
				) as (keyof typeof element)[];
				const attributes = attributeKeys
					.map((k) => element[k])
					.filter((v) => v !== undefined);
				attributes.forEach((attr) => {
					attr.id = '-1';
				});
				return data;
			}),
			switchMap((data: ElementDialog) =>
				data.element.id !== '-1' && data.element.id !== '0'
					? isArray
						? this.structureService.relateArrayElement(
								parent.id,
								data.element.id !== undefined
									? data.element.id
									: '-1',
								afterElement || 'end'
							)
						: this.structureService.relateElement(
								parent.id,
								data.element.id !== undefined
									? data.element.id
									: '-1',
								afterElement || 'end'
							)
					: isArray
						? this.structureService.createNewArrayElement(
								data.element,
								parent.id,
								afterElement || 'end'
							)
						: this.structureService.createNewElement(
								data.element,
								parent.id,
								afterElement || 'end'
							)
			)
		);
		createElement.subscribe();
	}
	openDeleteElementDialog(
		element: element,
		removeType: 'Structure' | 'Array'
	) {
		//open dialog, yes/no if yes -> this.structures.deleteElement()
		const dialogData: RemoveElementDialogData = {
			removeType: removeType,
			elementName: element.name.value,
		};
		this.dialog
			.open(RemoveElementDialogComponent, {
				data: dialogData,
			})
			.afterClosed()
			.pipe(
				take(1),
				switchMap((dialogResult: string) =>
					iif(
						() => dialogResult === 'ok',
						this.structureService.deleteElement(element),
						of()
					)
				)
			)
			.subscribe();
	}

	openEditElementDialog(element: element, isArrayChild: boolean) {
		const dialogData: ElementDialog = {
			id: '',
			name: '',
			startingElement: structuredClone(element),
			element: structuredClone(element),
			type: structuredClone(element.platformType),
			mode: 'edit',
			allowArray: false,
			arrayChild: isArrayChild,
			createdTypes: [],
		};
		const dialogRef = this.dialog.open(EditElementDialogComponent, {
			data: dialogData,
			minWidth: '70vw',
			minHeight: '80vh',
		});
		dialogRef
			.afterClosed()
			.pipe(
				take(1),
				filter(
					(val) =>
						val !== undefined &&
						val !== null &&
						val.element !== undefined &&
						val.type !== undefined
				),
				switchMap((val) =>
					this.structureService.changeElementFromDialog(val)
				)
			)
			.subscribe();
	}

	openEnumDialog(id: string, editMode: boolean) {
		this.platformTypeActionsService
			.openEnumDialog(id, editMode)
			.subscribe();
	}

	openDescriptionDialog(element: element, editMode: boolean) {
		const previousElement = structuredClone(element);
		this.dialog
			.open(EditViewFreeTextFieldDialogComponent, {
				data: {
					original: structuredClone(element.description.value),
					type: 'Description',
					return: element.description.value,
					editable: editMode,
				},
				minHeight: '60%',
				minWidth: '60%',
			})
			.afterClosed()
			.pipe(
				take(1),
				switchMap((response: EditViewFreeTextDialog | string) =>
					iif(
						() =>
							response === 'ok' ||
							response === 'cancel' ||
							response === undefined,
						//do nothing
						of(),
						//change description
						this.structureService.partialUpdateElement(
							{
								...element,
								description: {
									...element.description,
									value: (response as EditViewFreeTextDialog)
										.return,
								},
							},
							previousElement
						)
					)
				)
			)
			.subscribe();
	}

	/**
	 * Need to verify if type is required
	 */
	openEnumLiteralDialog(element: element, editMode: boolean) {
		const previousElement = structuredClone(element);
		this.dialog
			.open(EditViewFreeTextFieldDialogComponent, {
				data: {
					original: structuredClone(element.enumLiteral.value),
					type: 'Enum Literal',
					return: element.enumLiteral.value,
					editable: editMode,
				},
				minHeight: '60%',
				minWidth: '60%',
			})
			.afterClosed()
			.pipe(
				take(1),
				switchMap((response: EditViewFreeTextDialog | string) =>
					iif(
						() =>
							response === 'ok' ||
							response === 'cancel' ||
							response === undefined,
						//do nothing
						of(),
						//change description
						this.structureService.partialUpdateElement(
							{
								...element,
								enumLiteral: {
									...element.enumLiteral,
									value: (response as EditViewFreeTextDialog)
										.return,
								},
							},
							previousElement
						)
					)
				)
			)
			.subscribe();
	}

	openNotesDialog(element: element, editMode: boolean) {
		const previousElement = structuredClone(element);
		this.dialog
			.open(EditViewFreeTextFieldDialogComponent, {
				data: {
					original: structuredClone(element.notes.value),
					type: 'Notes',
					return: element.notes.value,
					editable: editMode,
				},
				minHeight: '60%',
				minWidth: '60%',
			})
			.afterClosed()
			.pipe(
				take(1),
				switchMap((response: EditViewFreeTextDialog | string) =>
					iif(
						() =>
							response === 'ok' ||
							response === 'cancel' ||
							response === undefined,
						//do nothing
						of(),
						//change notes
						this.structureService.partialUpdateElement(
							{
								...element,
								notes: {
									...element.notes,
									value: (response as EditViewFreeTextDialog)
										.return,
								},
							},
							previousElement
						)
					)
				)
			)
			.subscribe();
	}

	viewDiff<T>(value: difference<T> | undefined, header: string) {
		if (value !== undefined) {
			this.structureService.sideNav = {
				opened: true,
				field: header,
				currentValue: value.currentValue as string | number | applic,
				previousValue: value.previousValue as
					| string
					| number
					| applic
					| undefined,
				transaction: value.transactionToken,
			};
		}
	}

	hasChanges(v: element): v is Required<element> {
		return (
			(v as element).changes !== undefined ||
			(v as element).added !== undefined ||
			(v as element).deleted !== undefined
		);
	}
}
