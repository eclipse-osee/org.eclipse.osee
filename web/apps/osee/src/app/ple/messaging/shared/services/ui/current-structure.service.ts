/*********************************************************************
 * Copyright (c) 2023 Boeing
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Boeing - initial API and implementation
 **********************************************************************/
import { Injectable, effect, inject, signal } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { applic } from '@osee/applicability/types';
import type { MimQuery } from '@osee/messaging/shared/query';
import type {
	ElementDialog,
	element,
	settingsDialogData,
	structure,
	structureWithChanges,
} from '@osee/messaging/shared/types';
import { CurrentBranchInfoService } from '@osee/shared/services';
import { SideNavService } from '@osee/shared/services/layout';
import { changeInstance } from '@osee/shared/types/change-report';
import {
	ARTIFACTTYPEIDENUM,
	RELATIONTYPEIDENUM,
} from '@osee/shared/types/constants';
import {
	addRelation,
	createArtifact,
	deleteRelation,
	modifyArtifact,
} from '@osee/transactions/functions';
import { CurrentTransactionService } from '@osee/transactions/services';
import {
	legacyTransaction,
	transaction,
	transactionResult,
	transactionToken,
} from '@osee/transactions/types';
import {
	Observable,
	combineLatest,
	concat,
	concatMap,
	filter,
	from,
	iif,
	map,
	of,
	reduce,
	repeat,
	share,
	shareReplay,
	switchMap,
	take,
	tap,
} from 'rxjs';

import { PlatformTypeSentinel } from '@osee/messaging/shared/enumerations';
import { ElementService } from '../http/element.service';
import { MessagesService } from '../http/messages.service';
import { QueryService } from '../http/query.service';
import { StructuresService } from '../http/structures.service';
import { PreferencesUIService } from './preferences-ui.service';
import { StructuresUiService } from './structures-ui.service';
import { TypesUIService } from './types-ui.service';
import { WarningDialogService } from './warning-dialog.service';

@Injectable({
	providedIn: 'root',
})
export abstract class CurrentStructureService {
	private _types = this.typeService.types;
	private _expandedRows = signal<(structure | structureWithChanges)[]>([]);
	private _expandedRows$ = toObservable(this._expandedRows);
	constructor(
		protected ui: StructuresUiService,
		protected structure: StructuresService,
		protected messages: MessagesService,
		protected elements: ElementService,
		protected typeService: TypesUIService,
		protected preferenceService: PreferencesUIService,
		protected branchInfoService: CurrentBranchInfoService,
		protected sideNavService: SideNavService,
		protected queryService: QueryService,
		protected warningDialogService: WarningDialogService
	) {}

	private _currentTx = inject(CurrentTransactionService);

	abstract get currentPage(): Observable<number>;

	abstract set page(page: number);

	//eslint-disable-next-line @typescript-eslint/no-empty-function
	returnToFirstPage() {}

	abstract get currentPageSize(): Observable<number>;

	abstract set pageSize(page: number);

	get expandedRows() {
		return this._expandedRows;
	}

	protected _submessageId = toObservable(this.SubMessageId);
	get message() {
		return combineLatest([
			this.BranchId,
			this.connectionId,
			this.MessageId,
			this._submessageId,
			this.ui.viewId,
		]).pipe(
			switchMap(([branch, connection, id, submessageId, viewId]) =>
				this.messages.getMessage(branch, connection, id, viewId).pipe(
					repeat({ delay: () => this.ui.UpdateRequired }),
					tap((value) => {
						const submsg = value.subMessages.find(
							(submessage) => submessage.id === submessageId
						);
						const name =
							submsg?.name.value ?? 'Autogenerated Submessage';
						this.BreadCrumb = value.name.value + ' > ' + name;
					}),
					share()
				)
			),
			shareReplay({ bufferSize: 1, refCount: true })
		);
	}
	set addExpandedRow(value: structure) {
		this._expandedRows.update((rows) => [...rows, value]);
	}

	set removeExpandedRow(value: structure) {
		this._expandedRows.update((rows) =>
			rows.filter((v) => v.id !== value.id)
		);
	}

	clearRows() {
		this._expandedRows.set([]);
	}
	abstract get structures(): Observable<(structure | structureWithChanges)[]>;

	abstract get structuresCount(): Observable<number>;

	structureFilter = this.ui.filter;
	private _returnToFirstPageOnFilterChange = effect(
		() => {
			//very low chance this happens and it keeps the read working...
			if (this.structureFilter() !== crypto.randomUUID()) {
				this.returnToFirstPage();
				this.clearRows();
			}
		},
		{ allowSignalWrites: true }
	);

	set branchId(value: string) {
		this.ui.BranchIdString = value;
	}

	get BranchId() {
		return this.ui.BranchId;
	}

	get branchType() {
		return this.ui.branchType;
	}

	set BranchType(value: 'working' | 'baseline' | '') {
		this.ui.BranchType = value;
	}
	get BranchType() {
		return this.ui.branchType.getValue();
	}

	get viewId() {
		return this.ui.viewId;
	}

	set messageId(value: string) {
		this.ui.messageIdString = value;
	}

	get MessageId() {
		return this.ui.messageId;
	}

	get SubMessageId() {
		return this.ui.subMessageId;
	}

	set subMessageId(value: `${number}`) {
		this.ui.subMessageIdString = value;
	}

	set connection(id: `${number}`) {
		this.ui.connectionIdString = id;
	}

	connectionId = toObservable(this.ui.connectionId).pipe(
		filter((id) => id !== '-1')
	);

	get breadCrumbs() {
		return this.ui.subMessageBreadCrumbs;
	}

	set BreadCrumb(value: string) {
		this.ui.subMessageBreadCrumbsString = value;
	}

	set singleStructureIdValue(value: string) {
		this.ui.singleStructureIdValue = value;
	}

	get singleStructureId() {
		return this.ui.singleStructureId;
	}

	get preferences() {
		return this.preferenceService.preferences;
	}

	get BranchPrefs() {
		return this.preferenceService.BranchPrefs;
	}

	set toggleDone(value: boolean) {
		this.ui.toggleDone = value;
	}

	get done() {
		return this.ui.done;
	}

	get updated() {
		return this.ui.UpdateRequired;
	}

	get sideNavContent() {
		return this.sideNavService.rightSideNavContent;
	}

	set sideNav(value: {
		opened: boolean;
		field: string;
		currentValue: string | number | applic | boolean;
		previousValue?: string | number | applic | boolean;
		transaction?: transactionToken;
		user?: string;
		date?: string;
	}) {
		this.sideNavService.rightSideNav = value;
	}

	set update(value: boolean) {
		this.ui.updateMessages = value;
	}

	get availableStructures() {
		return this.BranchId.pipe(
			switchMap((id) =>
				this.structure
					.getStructures(id)
					.pipe(shareReplay({ bufferSize: 1, refCount: true }))
			),
			shareReplay({ bufferSize: 1, refCount: true })
		);
	}

	getPaginatedStructures(pageNum: string | number) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) =>
				this.structure.getPaginatedFilteredStructures(id, '', pageNum)
			)
		);
	}

	getPaginatedStructuresFilteredByName(
		name: string,
		count: number,
		pageNum: string | number
	) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) =>
				this.structure.getPaginatedStructuresFilteredByName(
					id,
					name,
					count,
					pageNum
				)
			)
		);
	}

	getStructuresFilteredByNameCount(name: string) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) =>
				this.structure.getStructuresFilteredByNameCount(id, name)
			)
		);
	}

	get availableElements() {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) => this.elements.getFilteredElements(id, ''))
		);
	}

	getType(typeId: string) {
		return this.BranchId.pipe(
			take(1),
			switchMap((_) => this.typeService.getType(typeId))
		);
	}

	getPaginatedElements(count: number, pageNum: string | number) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) =>
				this.elements.getPaginatedFilteredElements(
					id,
					'',
					count,
					pageNum.toString()
				)
			)
		);
	}

	getPaginatedElementsByName(
		name: string,
		count: number,
		pageNum: string | number
	) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) =>
				this.elements.getPaginatedElementsByName(
					id,
					name,
					count,
					pageNum
				)
			)
		);
	}

	getElementsByNameCount(name: string) {
		return this.BranchId.pipe(
			take(1),
			switchMap((id) => this.elements.getElementsByNameCount(id, name))
		);
	}

	get types() {
		return this._types;
	}

	get differences() {
		return this.ui.differences;
	}
	set difference(value: changeInstance[]) {
		this.ui.difference = value;
	}

	get isInDiff() {
		return this.ui.isInDiff;
	}

	set DiffMode(value: boolean) {
		this.ui.DiffMode = value;
	}

	get arrayIndexOrders() {
		return this.elements.getArrayIndexOrders();
	}

	get connectionsRoute() {
		return combineLatest([this.branchType, this.BranchId]).pipe(
			switchMap(([branchType, BranchId]) =>
				of('/ple/messaging/connections/' + branchType + '/' + BranchId)
			)
		);
	}

	createStructure(body: structure, afterStructure?: string) {
		const tx = this._createStructure(body, afterStructure);
		return this.warningDialogService
			.openSubMessageDialog({ id: this.SubMessageId() })
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}
	private _createStructure(body: structure, afterStructure?: string) {
		const {
			id,
			gammaId,
			elements,
			numElements,
			sizeInBytes,
			bytesPerSecondMinimum,
			bytesPerSecondMaximum,
			incorrectlySized,
			autogenerated,
			applicability,
			added,
			deleted,
			hasElementChanges,
			changes,
			...remainingAttributes
		} = body;
		const attributeKeys = Object.keys(
			remainingAttributes
		) as (keyof typeof remainingAttributes)[];
		const attributes = attributeKeys
			.map((k) => remainingAttributes[k])
			.filter((attr) => attr.id !== '');
		let tx = this._currentTx.createTransaction(
			`Creating Structure ${body.name.value}`
		);
		const elementRels = elements
			.filter((v) => v.id !== '-1' && !v.autogenerated)
			.map((el) => {
				return {
					typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
					sideB: el.id,
				};
			});
		const submsg = this.SubMessageId();
		const submsgRels =
			submsg !== '-1' && submsg !== '0'
				? [
						{
							typeId: RELATIONTYPEIDENUM.INTERFACESUBMESSAGECONTENT,
							sideA: submsg,
							afterArtifact: afterStructure || 'end',
						},
					]
				: [];
		const results = createArtifact(
			tx,
			ARTIFACTTYPEIDENUM.STRUCTURE,
			applicability,
			[...submsgRels, ...elementRels],
			undefined,
			...attributes
		);
		//store off a reference to allow elements to be copied over
		const createdStructure = results._newArtifact;
		elements.forEach((el) => {
			if (el.id === '-1' && !el.autogenerated) {
				tx = this.createNewElementTx(tx, el, createdStructure.key);
			}
		});
		return tx;
	}

	copyStructure(body: structure, afterStructure?: string) {
		//zero out the ids of attributes so they can be created
		body.name.id = '-1';
		body.description.id = '-1';
		body.nameAbbrev.id = '-1';
		body.interfaceMaxSimultaneity.id = '-1';
		body.interfaceMinSimultaneity.id = '-1';
		body.interfaceStructureCategory.id = '-1';
		body.interfaceTaskFileType.id = '-1';
		return this.createStructure(body, afterStructure);
	}

	relateStructure(structureId: `${number}`, afterStructure?: string) {
		let tx = this._currentTx.createTransaction(
			`Relating structure ${structureId} to ${this.ui.subMessageId()}`
		);
		tx = addRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACESUBMESSAGECONTENT,
			aArtId: this.ui.subMessageId(),
			bArtId: structureId,
			afterArtifact: afterStructure ?? 'end',
		});
		const warning = this._submessageId.pipe(
			switchMap((submsg) =>
				this.warningDialogService.openSubMessageDialog({ id: submsg })
			)
		);
		return warning.pipe(
			map((_) => tx),
			this._currentTx.performMutation()
		);
	}

	private _getStructureAttributes(body: structure) {
		const {
			id,
			gammaId,
			elements,
			numElements,
			sizeInBytes,
			bytesPerSecondMinimum,
			bytesPerSecondMaximum,
			incorrectlySized,
			autogenerated,
			applicability,
			added,
			deleted,
			hasElementChanges,
			changes,
			...remainingAttributes
		} = body;
		const attributeKeys = Object.keys(
			remainingAttributes
		) as (keyof typeof remainingAttributes)[];
		const attributes = attributeKeys
			.map((k) => remainingAttributes[k])
			.filter((attr) => attr.id !== '');
		return attributes;
	}
	partialUpdateStructure(body: structure, previous: structure) {
		const {
			id,
			gammaId,
			elements,
			numElements,
			sizeInBytes,
			bytesPerSecondMinimum,
			bytesPerSecondMaximum,
			incorrectlySized,
			autogenerated,
			applicability,
			added,
			deleted,
			hasElementChanges,
			changes,
			...remainingAttributes
		} = body;
		const attributeKeys = Object.keys(
			remainingAttributes
		) as (keyof typeof remainingAttributes)[];
		const attributes = attributeKeys
			.map((k) => remainingAttributes[k])
			.filter((attr) => attr.id !== '');
		const previousAttributes = this._getStructureAttributes(previous);
		const addAttributes = attributes.filter((v) => v.id === '-1');
		const modifyAttributes = attributes
			.filter((v) => v.id !== '-1')
			.filter(
				(v) =>
					previousAttributes.filter(
						(x) =>
							x.id === v.id &&
							x.typeId === v.typeId &&
							x.gammaId === v.gammaId &&
							x.value !== v.value
					).length > 0
			);
		const deleteAttributes = previousAttributes.filter(
			(v) => !attributes.map((x) => x.id).includes(v.id)
		);
		return this.warningDialogService.openStructureDialog(body).pipe(
			switchMap((_) =>
				this._currentTx.modifyArtifactAndMutate(
					`Modifying ${previous.name.value}`,
					previous.id,
					applicability,
					{
						set: modifyAttributes,
						add: addAttributes,
						delete: deleteAttributes,
					}
				)
			)
		);
	}

	private _getElementAttributes(body: element) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...remainingAttributes
		} = body;
		const attributeKeys = Object.keys(
			remainingAttributes
		) as (keyof typeof remainingAttributes)[];
		const attributes = attributeKeys
			.map((k) => remainingAttributes[k])
			.filter((attr) => attr !== undefined && attr.id !== '');
		return attributes;
	}
	partialUpdateElement(body: element, previousElement: element) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...remainingAttributes
		} = body;
		const attributeKeys = Object.keys(
			remainingAttributes
		) as (keyof typeof remainingAttributes)[];
		const attributes = attributeKeys
			.map((k) => remainingAttributes[k])
			.filter((attr) => attr !== undefined && attr.id !== '');
		const previousAttributes = this._getElementAttributes(previousElement);
		const addAttributes = attributes.filter((v) => v.id === '-1');
		const modifyAttributes = attributes
			.filter((v) => v.id !== '-1')
			.filter(
				(v) =>
					previousAttributes.filter(
						(x) =>
							x.id === v.id &&
							x.typeId === v.typeId &&
							x.gammaId === v.gammaId &&
							x.value !== v.value
					).length > 0
			);
		const deleteAttributes = previousAttributes.filter(
			(v) => !attributes.map((x) => x.id).includes(v.id)
		);
		return this.warningDialogService.openElementDialogById(id).pipe(
			switchMap((_) =>
				this._currentTx.modifyArtifactAndMutate(
					`Modifying ${previousElement.name.value}`,
					previousElement.id,
					applicability,
					{
						set: modifyAttributes,
						add: addAttributes,
						delete: deleteAttributes,
					}
				)
			)
		);
	}

	createNewElementTx(
		tx: Required<transaction>,
		body: element,
		structureId: string,
		afterElement?: string
	) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...element
		} = body;
		const attributeKeys = Object.keys(element) as (keyof typeof element)[];
		const attributes = attributeKeys.map((k) => element[k]);
		const startingRels =
			platformType.id !== '-1' && platformType.id !== '0'
				? [
						{
							typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
							sideA: structureId,
							afterArtifact: afterElement || 'end',
						},
						{
							typeId: RELATIONTYPEIDENUM.INTERFACEELEMENTPLATFORMTYPE,
							sideB: platformType.id,
						},
					]
				: [
						{
							typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
							sideA: structureId,
							afterArtifact: afterElement || 'end',
						},
					];
		const results = this._currentTx.createArtifact(
			`Creating element ${element.name.value}`,
			ARTIFACTTYPEIDENUM.ELEMENT,
			applicability,
			startingRels,
			...attributes
		);
		tx = results.tx;
		const _newArtifact = results._newArtifact;
		//simple rename
		const topLevelElement = structuredClone(_newArtifact);
		if (
			platformType.id === '-1' &&
			!element.interfaceElementArrayHeader.value
		) {
			//create platform type
			const pTypeResults = this.typeService.createPlatformType(
				platformType,
				tx,
				topLevelElement.key
			);
			tx = pTypeResults.tx;
		} else if (
			platformType.id === '0' ||
			element.interfaceElementArrayHeader.value
		) {
			//platform type is array header, so we should create/relate elements
			const els = arrayElements
				.map((x) => x.platformType)
				.filter((x) => x.id === '-1')
				.map((v) => JSON.stringify(v))
				.filter((v, i, arr) => arr.indexOf(v) === i);
			// .map((v) => JSON.parse(v) as PlatformType);
			const pTypesToCreate = new Map(
				els.map((y) => {
					return [y, { present: false, key: '' }];
				})
			);
			arrayElements.forEach((el) => {
				if (el.id !== '-1' && el.id !== '0') {
					//do a relation
					tx = addRelation(tx, {
						typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
						aArtId: topLevelElement.key,
						bArtId: el.id,
					});
				} else {
					tx = this.createChildElement(
						pTypesToCreate,
						el,
						topLevelElement.key,
						tx
					);
				}
			});
		} else {
			// do nothing - platform type relation already exists
		}
		return tx;
	}

	createNewElement(
		body: element,
		structureId: `${number}`,
		afterElement?: string
	) {
		let tx = this._currentTx.createTransaction(
			`Creating element ${body.name.value}`
		);
		tx = this.createNewElementTx(tx, body, structureId, afterElement);
		return of(tx).pipe(this._currentTx.performMutation());
	}

	createChildElement(
		pTypesToCreate: Map<string, { present: boolean; key: string }>,
		body: element,
		parentKey: string,
		existingTx: Required<transaction>,
		afterArtifact?: string
	) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...element
		} = body;
		const attributeKeys = Object.keys(element) as (keyof typeof element)[];
		//TODO: not sure why undefined is showing up down here
		const attributes = attributeKeys
			.map((k) => element[k])
			.filter((v) => v !== undefined);
		if (body.id === '-1' || body.id === '0') {
			if (body.platformType.id !== '-1' && body.platformType.id !== '0') {
				//case 1: Platform Type already exists, so just create the child element with the existing platform type
				createArtifact(
					existingTx,
					ARTIFACTTYPEIDENUM.ELEMENT,
					applicability,
					[
						{
							typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
							sideA: parentKey,
							afterArtifact: afterArtifact || 'end',
						},
						{
							typeId: RELATIONTYPEIDENUM.INTERFACEELEMENTPLATFORMTYPE,
							sideB: platformType.id,
						},
					],
					undefined,
					...attributes
				);
			} // create artifact(include relation: ARRAY SIDEA from topLevelElement, sideB platformType)
			else if (
				body.platformType.id === '-1' &&
				pTypesToCreate.get(JSON.stringify(body.platformType)) !==
					undefined
			) {
				//case 2a: platform type doesn't exist and element doesn't exist, so create both and relate them together
				const { tx, ...newElement } = createArtifact(
					existingTx,
					ARTIFACTTYPEIDENUM.ELEMENT,
					applicability,
					[
						{
							typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
							sideA: parentKey,
							afterArtifact: afterArtifact || 'end',
						},
					],
					undefined,
					...attributes
				);
				//The check is done above
				const pTypeStatus = pTypesToCreate.get(
					JSON.stringify(body.platformType)
				);
				if (!pTypeStatus?.present) {
					// create the platform type
					const results = this.typeService.createPlatformType(
						platformType,
						tx,
						newElement._newArtifact.key
					);
					// set the key and present flag in pTypesToCreate
					pTypesToCreate.set(JSON.stringify(body.platformType), {
						present: true,
						key: results.createdType._newArtifact.key,
					});
				} else if (body.platformType.id === '-1') {
					//case 2b: platform type doesn't exist and element doesn't exist, but platform type has already been created,
					//so let's just reuse the key in the tx
					addRelation(tx, {
						typeId: RELATIONTYPEIDENUM.INTERFACEELEMENTPLATFORMTYPE,
						aArtId: newElement._newArtifact.key,
						bArtId: pTypeStatus.key,
					});
				} else {
					//do nothing
				}
				return tx;
			}
		}
		return existingTx;
	}
	createNewArrayElement(
		body: element,
		headerElementId: string,
		afterElement?: string
	) {
		let tx = this._currentTx.createTransaction(
			`Creating array element ${body.name.value}`
		);
		tx = this.createChildElement(
			new Map(),
			body,
			headerElementId,
			tx,
			afterElement
		);
		return of(tx).pipe(this._currentTx.performMutation());
	}

	relateElement(
		structureId: `${number}`,
		elementId: `${number}`,
		afterElement?: string
	) {
		let tx = this._currentTx.createTransaction(
			`Relating element ${elementId} to ${structureId}`
		);
		tx = addRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
			aArtId: structureId,
			bArtId: elementId,
			afterArtifact: afterElement ?? 'end',
		});
		return this.warningDialogService
			.openStructureDialog({ id: structureId })
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}

	relateArrayElement(
		headerElementId: `${number}`,
		elementId: `${number}`,
		afterElementId?: string
	) {
		let tx = this._currentTx.createTransaction(
			`Relating element ${elementId} to ${headerElementId}`
		);
		tx = addRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
			aArtId: headerElementId,
			bArtId: elementId,
			afterArtifact: afterElementId ?? 'end',
		});
		return this.warningDialogService
			.openElementDialogById(headerElementId)
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}

	changeElementRelationOrder(
		structureId: `${number}`,
		elementId: `${number}`,
		afterArtifactId: string
	) {
		let tx = this._currentTx.createTransaction(
			`Reordering element ${elementId} to ${structureId}`
		);
		tx = deleteRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
			aArtId: structureId,
			bArtId: elementId,
		});
		tx = addRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
			aArtId: structureId,
			bArtId: elementId,
			afterArtifact: afterArtifactId ?? 'end',
		});
		return this.warningDialogService
			.openStructureDialog({ id: structureId })
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}

	changeElementArrayRelationOrder(
		arrayHeaderId: `${number}`,
		elementId: `${number}`,
		afterArtifactId: string
	) {
		let tx = this._currentTx.createTransaction(
			`Reordering element ${elementId} to ${arrayHeaderId}`
		);
		tx = deleteRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
			aArtId: arrayHeaderId,
			bArtId: elementId,
		});
		tx = addRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
			aArtId: arrayHeaderId,
			bArtId: elementId,
			afterArtifact: afterArtifactId ?? 'end',
		});
		return this.warningDialogService
			.openElementDialogById(arrayHeaderId)
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}

	changeElementFromDialog(dialog: ElementDialog) {
		const results = this._changeElementFromDialog(dialog);
		const tx = results.tx;
		const elements = results.modifiedElements;
		const dialogs = from(elements).pipe(
			concatMap((el) =>
				this.warningDialogService
					.openElementDialogById(el)
					.pipe(map((_) => true))
			),
			reduce((acc, curr) => [...acc, curr], [] as boolean[])
		);
		return dialogs.pipe(
			filter((v) => v.length === elements.length),
			map((_) => tx),
			this._currentTx.performMutation()
		);
	}
	private _getAttributesFromElement(el: element) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...element
		} = el;
		const attributeKeys = Object.keys(element) as (keyof typeof element)[];
		const attributes = attributeKeys
			.map((k) => element[k])
			.filter((v) => v !== undefined);
		return attributes;
	}

	private _changeElementFromDialog(
		dialog: ElementDialog,
		existingTx?: Required<transaction>
	) {
		const {
			id,
			gammaId,
			autogenerated,
			elementSizeInBits,
			elementSizeInBytes,
			beginByte,
			beginWord,
			endByte,
			endWord,
			arrayElements,
			platformType,
			applicability,
			added,
			deleted,
			changes,
			...element
		} = dialog.element;
		const modifiedElements: `${number}`[] = [];
		const attributeKeys = Object.keys(element) as (keyof typeof element)[];
		const attributes = attributeKeys
			.map((k) => element[k])
			.filter((v) => v !== undefined);
		let tx = existingTx
			? existingTx
			: this._currentTx.createTransaction(
					`Editing element ${dialog.element.name.value}`
				);
		if (platformType.id === '-1' && platformType.name.value !== '') {
			tx = this.typeService.createPlatformType(
				platformType,
				tx,
				dialog.element.id
			).tx;
		} else if (
			JSON.stringify(dialog.startingElement.platformType) !==
				JSON.stringify(platformType) &&
			dialog.startingElement.platformType.id !== '0' &&
			platformType.id !== '-1'
		) {
			//perform updates to the relations if this condition is true
			//if dialog.element.platformType ==='-1', create a platform type that is related to the element
			tx = deleteRelation(tx, {
				typeId: RELATIONTYPEIDENUM.INTERFACEELEMENTPLATFORMTYPE,
				aArtId: id,
				bArtId: dialog.startingElement.platformType.id,
			});
			tx = addRelation(tx, {
				typeId: RELATIONTYPEIDENUM.INTERFACEELEMENTPLATFORMTYPE,
				aArtId: id,
				bArtId: platformType.id,
			});
		}
		const attributesModified = attributes
			.filter((v) => v.id !== '-1')
			.filter((attr) => {
				const _attributes = this._getAttributesFromElement(
					dialog.startingElement
				);
				const _attribute = _attributes.find((v) => v.id === attr.id);
				if (_attribute) {
					return _attribute.value !== attr.value;
				}
				return true;
			});
		tx = modifyArtifact(tx, id, applicability, {
			set: attributesModified,
			add: attributes.filter((v) => v.id === '-1' && v.value !== ''),
		});
		modifiedElements.push(id);
		/**
		 * for each element in arrayElements,
		 * compare to see if it existed in the startingElement
		 * if the id ==='-1', create it
		 * if it did exist, and is the same, do nothing
		 * if it did exist, and is different, modify it(same as this method)
		 * if it didn't exist, modify it(same as this method) and then relate it --note: can't do modify it currently, as we don't know what the previous state of the element was
		 *
		 * for each element in startingElement.arrayElements
		 * if it doesn't exist in arrayElements, remove it
		 */
		const elementsToCreate = arrayElements.filter((v) => v.id === '-1');
		const els = elementsToCreate
			.map((x) => x.platformType)
			.map((v) => JSON.stringify(v))
			.filter((v, i, arr) => arr.indexOf(v) === i);
		const pTypesToCreate = new Map(
			els.map((y) => {
				return [y, { present: false, key: '' }];
			})
		);
		elementsToCreate.forEach((v) => {
			tx = this.createChildElement(pTypesToCreate, v, id, tx);
		});
		const elementsToPotentiallyModify = arrayElements.filter(
			(v) => v.id !== '-1'
		);
		elementsToPotentiallyModify.forEach((el) => {
			const foundElement = dialog.startingElement.arrayElements.find(
				(v) => v.id === el.id
			);
			if (
				foundElement &&
				JSON.stringify(foundElement) !== JSON.stringify(el)
			) {
				//modify it
				const results = this._changeElementFromDialog(
					{
						id: '',
						name: '',
						startingElement: foundElement,
						element: el,
						mode: 'edit',
						allowArray: false,
						arrayChild: false,
						createdTypes: [],
						type: new PlatformTypeSentinel(),
					},

					tx
				);
				tx = results.tx;
			}
			if (!foundElement) {
				//relate
				tx = addRelation(tx, {
					typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
					aArtId: id,
					bArtId: el.id,
				});
			}
		});
		dialog.startingElement.arrayElements.forEach((el) => {
			const foundElement = arrayElements.find((v) => v.id === el.id);
			if (!foundElement) {
				tx = deleteRelation(tx, {
					typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
					aArtId: id,
					bArtId: el.id,
				});
			}
		});
		return { tx, modifiedElements };
	}

	updatePreferences(preferences: settingsDialogData) {
		return concat(
			this._deleteColumnPrefs(),
			this._deleteBranchPrefs(),
			this._setBranchPrefs(preferences.editable),
			this._setColumnPrefs(preferences)
		).pipe(
			take(4),
			reduce((acc, curr) => [...acc, curr], [] as transactionResult[]),
			tap(() => {
				this.ui.updateMessages = true;
			})
		);
	}

	private _deleteBranchPrefs() {
		return this.preferences.pipe(
			take(1),
			switchMap((prefs) =>
				iif(
					() => prefs.hasBranchPref,
					of<legacyTransaction>({
						branch: '570',
						txComment: 'Updating MIM User Preferences',
						modifyArtifacts: [
							{
								id: prefs.id,
								deleteAttributes: [
									{ typeName: 'MIM Branch Preferences' },
								],
							},
						],
					}),
					of(undefined)
				)
			),
			switchMap((transaction) =>
				iif(
					() => transaction !== undefined,
					this.structure.performMutation(transaction!),
					of()
				)
			)
		);
	}

	private _deleteColumnPrefs() {
		return this.preferences.pipe(
			take(1),
			switchMap((prefs) =>
				iif(
					() => prefs.columnPreferences.length !== 0,
					of<legacyTransaction>({
						branch: '570',
						txComment: 'Updating MIM User Preferences',
						modifyArtifacts: [
							{
								id: prefs.id,
								deleteAttributes: [
									{ typeName: 'MIM Column Preferences' },
								],
							},
						],
					}),
					of(undefined)
				)
			),
			switchMap((transaction) =>
				iif(
					() => transaction !== undefined,
					this.structure.performMutation(transaction!),
					of()
				)
			)
		);
	}

	private _setBranchPrefs(editMode: boolean) {
		return combineLatest([
			this.preferences,
			this.BranchId,
			this.BranchPrefs,
		]).pipe(
			take(1),
			switchMap(([prefs, branch, branchPrefs]) =>
				iif(
					() => prefs.hasBranchPref,
					of<legacyTransaction>({
						branch: '570',
						txComment: 'Updating MIM User Preferences',
						modifyArtifacts: [
							{
								id: prefs.id,
								addAttributes: [
									{
										typeName: 'MIM Branch Preferences',
										value: [
											...branchPrefs,
											`${branch}:${editMode}`,
										],
									},
								],
							},
						],
					}),
					of<legacyTransaction>({
						branch: '570',
						txComment: 'Updating MIM User Preferences',
						modifyArtifacts: [
							{
								id: prefs.id,
								addAttributes: [
									{
										typeName: 'MIM Branch Preferences',
										value: `${branch}:${editMode}`,
									},
								],
							},
						],
					})
				)
			),
			switchMap((transaction) =>
				this.structure.performMutation(transaction)
			)
		);
	}

	private _setColumnPrefs(newPreferences: settingsDialogData) {
		return combineLatest([
			this.preferences,
			this.createColumnPreferences(newPreferences),
		]).pipe(
			take(1),
			switchMap(([prefs, [_columns, allColumns]]) =>
				of<legacyTransaction>({
					branch: '570',
					txComment: 'Updating MIM User Preferences',
					modifyArtifacts: [
						{
							id: prefs.id,
							addAttributes: [
								{
									typeName: 'MIM Column Preferences',
									value: allColumns,
								},
							],
						},
					],
				})
			),
			switchMap((transaction) =>
				this.structure.performMutation(transaction)
			)
		);
	}
	private createColumnPreferences(preferences: settingsDialogData) {
		const columnPrefs: string[] = [];
		let allColumns: string[] = [];
		const temp = [...preferences.allHeaders1, ...preferences.allHeaders2];
		const allHeaders = temp.filter(
			(item, pos) => temp.indexOf(item) === pos
		);
		[
			...preferences.allowedHeaders1,
			...preferences.allowedHeaders2,
		].forEach((header) => {
			if (
				allHeaders.includes(header) &&
				(!(
					allColumns.includes(`${header}:true`) ||
					allColumns.includes(`${header}:false`)
				) ||
					!(
						allColumns.includes(`"${header}:true"`) ||
						allColumns.includes(`"${header}:false"`)
					))
			) {
				allColumns.push(`"${header}:true"`);
				columnPrefs.push(`"${header}:true"`);
			} else if (
				!(
					allColumns.includes(`${header}:true`) ||
					allColumns.includes(`${header}:false`)
				) ||
				allColumns.includes(`"${header}:true"`) ||
				allColumns.includes(`"${header}:false"`)
			) {
				allColumns.push(`"${header}:false"`);
			}
		});
		allColumns = allColumns.filter(
			(item, pos) => allColumns.indexOf(item) === pos
		);
		return of([columnPrefs, allColumns]);
	}

	removeStructureFromSubmessage(
		structureId: string,
		submessageId: `${number}`
	) {
		return this.ui.BranchId.pipe(
			take(1),
			filter((id) => id !== undefined && id !== '' && id !== '-1'),
			switchMap((id) =>
				this.warningDialogService
					.openSubMessageDialog({ id: submessageId })
					.pipe(map((_) => id))
			),
			switchMap((branchId) =>
				this.structure
					.deleteSubmessageRelation(
						branchId,
						submessageId,
						structureId
					)
					.pipe(
						switchMap((transaction) =>
							this.structure.performMutation(transaction).pipe(
								tap(() => {
									this.ui.updateMessages = true;
								})
							)
						)
					)
			)
		);
	}
	removeElementFromStructure(element: element, structure: structure) {
		let tx = this._currentTx.createTransaction(
			`Removing ${element.id} from ${structure.id}`
		);
		tx = deleteRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACESTRUCTURECONTENT,
			aArtId: structure.id,
			bArtId: element.id,
		});
		return this.warningDialogService.openStructureDialog(structure).pipe(
			map((_) => tx),
			this._currentTx.performMutation()
		);
	}

	removeElementFromArray(element: element, headerElement: element) {
		let tx = this._currentTx.createTransaction(
			`Removing ${element.id} from ${headerElement.id}`
		);
		tx = deleteRelation(tx, {
			typeId: RELATIONTYPEIDENUM.INTERFACELEMENTARRAY,
			aArtId: headerElement.id,
			bArtId: element.id,
		});
		return this.warningDialogService
			.openElementDialogById(headerElement.id)
			.pipe(
				map((_) => tx),
				this._currentTx.performMutation()
			);
	}

	deleteElement(element: element) {
		return this.warningDialogService
			.openElementDialog(element)
			.pipe(
				switchMap((_) =>
					this._currentTx.deleteArtifactAndMutate(
						`Deleting element ${element.name.value}`,
						element.id
					)
				)
			);
	}

	deleteStructure(structureId: `${number}`) {
		return this.ui.BranchId.pipe(
			take(1),
			filter((id) => id !== undefined && id !== '' && id !== '-1'),
			switchMap((branch) =>
				this.warningDialogService
					.openStructureDialog({ id: structureId })
					.pipe(map((_) => branch))
			),
			switchMap((branchId) =>
				this.structure.deleteStructure(branchId, structureId).pipe(
					switchMap((transaction) =>
						this.structure.performMutation(transaction).pipe(
							tap(() => {
								this.ui.updateMessages = true;
							})
						)
					)
				)
			)
		);
	}

	protected _elementChangeSetup(element: element): Required<element> {
		if ((element as element).changes === undefined) {
			(element as element).changes = {};
		}
		if ((element as element).added === undefined) {
			(element as element).added = false;
		}
		if ((element as element).deleted === undefined) {
			(element as element).deleted = false;
		}
		return element as Required<element>;
	}

	protected _elementIsDiffed(element: element): element is Required<element> {
		return (
			element.changes !== undefined &&
			element.added !== undefined &&
			element.deleted !== undefined
		);
	}
	protected _structureChangeSetup(
		structure: structure | structureWithChanges
	): structureWithChanges {
		if ((structure as structureWithChanges).changes === undefined) {
			(structure as structureWithChanges).changes = {};
		}
		return structure as structureWithChanges;
	}
	query<T = unknown>(query: MimQuery<T>) {
		return this.BranchId.pipe(
			switchMap((id) =>
				this.queryService
					.query<T>(id, query)
					.pipe(shareReplay({ bufferSize: 1, refCount: true }))
			)
		);
	}

	validateStructure(art: `${number}`) {
		return this.warningDialogService.openStructureDialogForValidation(art);
	}

	validateElement(art: `${number}`) {
		return this.warningDialogService.openElementDialogForValidation(art);
	}
}
